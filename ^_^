Анализ алгоритмов поиска

1. Линейный поиск (Linear Search)

1. Инициализация: Вводится массив чисел и его размер. Пользователь вводит искомое число.


2. Поиск:

Программа проходит по каждому элементу массива, начиная с arr[0].

Сравнивает текущий элемент с искомым значением.

Если элемент совпал с target, программа возвращает его индекс.



3. Выход из цикла:

Если найден, выводится сообщение с индексом элемента.

Если прошли весь массив и не нашли элемент, программа возвращает -1, сообщая, что элемента нет.




Сложность алгоритма:

В худшем случае (если элемент отсутствует или находится в конце) – O(n).

В лучшем случае (если первый элемент – это target) – O(1).



---

2. Бинарный поиск (Binary Search)

1. Инициализация: Принимается отсортированный массив, его границы left = 0 и right = size - 1, вводится искомое число.


2. Циклический процесс:

Находится mid = left + (right - left) / 2 (средний индекс).

Сравнивается arr[mid] с target.

Если arr[mid] == target, возвращается mid.

Если arr[mid] < target, поиск продолжается в правой половине (left = mid + 1).

Если arr[mid] > target, поиск идет в левой половине (right = mid - 1).



3. Выход из цикла:

Если left > right, значит, элемента нет.




Сложность алгоритма:

В худшем случае – O(log n) (делим массив пополам на каждом шаге).

В лучшем случае – O(1) (если mid сразу равен target).



---

3. Интерполяционный поиск (Interpolation Search)

1. Инициализация: Принимается отсортированный массив. Пользователь вводит искомое значение.


2. Расчет позиции:

Вместо середины (как в бинарном поиске), вычисляется pos по формуле линейной интерполяции:

pos = low + ((target - arr[low]) * (high - low)) / (arr[high] - arr[low])

Оценка pos основана на пропорциональном распределении элементов в массиве.



3. Поиск:

Если arr[pos] == target, возвращается pos.

Если arr[pos] < target, поиск продолжается в правой части (low = pos + 1).

Если arr[pos] > target, поиск продолжается в левой части (high = pos - 1).



4. Выход из цикла:

Если low > high или target выходит за границы диапазона, элемента нет.




Сложность алгоритма:

В лучшем случае – O(1) (если target на вычисленной позиции).

В среднем случае – O(log log n) (быстрее бинарного на равномерно распределенных данных).

В худшем случае (неравномерные данные) – O(n).



---

4. Построчный поиск (Search by Rows)

1. Инициализация: Создается двумерный массив, вводится искомый элемент.


2. Проход по строкам и столбцам:

Два вложенных цикла: первый идет по строкам i, второй по столбцам j.

Проверяется matrix[i][j] == target.

Если найден, выводится координата (i, j), и программа завершает поиск.



3. Выход из поиска:

Если элемент найден, программа сразу выходит.

Если после полного прохода элемента нет, выводится сообщение.




Сложность алгоритма:

В худшем случае – O(n * m) (где n – количество строк, m – столбцов).

В лучшем случае – O(1) (если target находится в matrix[0][0]).



---

Вывод

1. Линейный поиск – прост, но медленный (O(n)).


2. Бинарный поиск – работает быстрее (O(log n)), но требует отсортированного массива.


3. Интерполяционный поиск – быстрее бинарного на равномерных данных (O(log log n)), но неэффективен для случайных чисел.


4. Построчный поиск – удобен для двумерных массивов, но менее оптимален (O(n * m)).



